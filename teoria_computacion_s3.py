# -*- coding: utf-8 -*-
"""Teoria Computacion S3

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GYIN-2BmabUzoeS2kwkiaeFS61dl0cTy

**Automata cuyo lenguaje acepte una {A, B}**
"""

import networkx as nx

G = nx.MultiDiGraph()
G.add_node("Q0")
G.add_node("Q1")

G.add_edge("Q0","Q0",weight=1) #A
G.add_edge("Q0","Q1",weight=7) #B

print("Nodes of graph: ")
print(G.nodes())
print("Edges of graph: ")
print(G.edges())

print("Weight:")
print("Q0-Q0 {relacion a}"  ,
      G.get_edge_data("Q0","Q0"))
print("Q0-Q1 {relacion b}" ,
    G.get_edge_data("Q0","Q1"))

nx.draw(G, with_labels=True, node_color='green', node_size=1000)

"""### **DFA** 
(deterministico)

Lleva epsilon, no puede tener loop en el estado inicial, si tambien es estado final. ya que si es DFA solo puede salir una (linea,transicion,edge) de ella (estado inicial).

## **NFA**
(no deterministico)

Permite mas de una (transicion, linea)

Transicion ejemplo:

{q1,'b'} - {q0,q2}

**Sea M un DFA. Cuando pertenece Epsilon a L(M)?**

R// Si epsilon es parte del lenguaje, Si esta q0 es estado inicial y final.

### **Construir los DFA que aceptan cada uno de estos lenguajes sobre {a,b}**

**(a) {W | toda a de w esta entre dos b}**

✓ bab

✓ bbbb

✓ b

✓ Epsilon
"""

import networkx as nx

G = nx.MultiDiGraph()
G.add_node("Q0")
G.add_node("Q1")
G.add_node("Q2")

G.add_edge("Q0","Q1",weight=1) #B
G.add_edge("Q1","Q1",weight=7) #B
G.add_edge("Q1","Q2",weight=3) #A
G.add_edge("Q2","Q1",weight=4) #B

print("Nodes of graph: ")
print(G.nodes())
print("Edges of graph: ")
print(G.edges())

print("Weight:")
print("Q0-Q1 {relacion b}" ,
      G.get_edge_data("Q0","Q1"))
print("Q1-Q1 {relacion b}" ,
    G.get_edge_data("Q1","Q1"))
print("Q1-Q2 {relacion a}" ,
      G.get_edge_data("Q1","Q2"))
print("Q2-Q1 {relacion b}" ,
    G.get_edge_data("Q2","Q1"))

nx.draw(G, with_labels=True, node_color='red', node_size=1000)

"""**(b) {W | w contiene la subcadena abab**}"""

import networkx as nx

G = nx.MultiDiGraph()
G.add_node("Q0")
G.add_node("Q1")
G.add_node("Q2")
G.add_node("Q3")
G.add_node("Q4")

G.add_edge("Q0","Q0",weight=1) #B
G.add_edge("Q0","Q1",weight=7) #A
G.add_edge("Q1","Q1",weight=3) #A
G.add_edge("Q1","Q2",weight=4) #B
G.add_edge("Q2","Q1",weight=1) #A
G.add_edge("Q2","Q0",weight=7) #B
G.add_edge("Q2","Q3",weight=3) #A
G.add_edge("Q3","Q1",weight=4) #A
G.add_edge("Q3","Q4",weight=3) #B
G.add_edge("Q4","Q4",weight=4) #A
G.add_edge("Q4","Q4",weight=5) #B

print("Nodes of graph: ")
print(G.nodes())
print("Edges of graph: ")
print(G.edges())

print("Weight:")
print("Q0-Q0 {relacion b}" ,
      G.get_edge_data("Q0","Q0"))
print("Q0-Q1 {relacion a}" ,
    G.get_edge_data("Q0","Q1"))
print("Q1-Q1 {relacion a}" ,
      G.get_edge_data("Q1","Q1"))
print("Q1-Q2 {relacion b}" ,
    G.get_edge_data("Q1","Q2"))
print("Q2-Q1 {relacion a}" ,
      G.get_edge_data("Q2","Q1"))
print("Q2-Q0 {relacion b}" ,
    G.get_edge_data("Q2","Q0"))
print("Q2-Q3 {relacion a}" ,
      G.get_edge_data("Q2","Q3"))
print("Q3-Q1 {relacion a}" ,
    G.get_edge_data("Q3","Q1"))
print("Q3-Q4 {relacion b}" ,
      G.get_edge_data("Q3","Q4"))
print("Q4-Q4 {relacion a}" ,
    G.get_edge_data("Q4","Q4"))
print("Q4-Q4 {relacion b}" ,
      G.get_edge_data("Q4","Q4"))

nx.draw(G, with_labels=True, node_size=1000)

"""### **Expresiones Regulares y Automatas Finitos Deterministicos**

**M = (Q,∑,s,F,Δ)**

∑ = Alfabeto de entrada

s = Estado Inicial

Q = Coleccion finita de estado

F = Coleccion de estados finales o de aceptacion

Δ = Es la relacion (Qx∑)xQ, se llama relacion de transicion

***Eliminacion Estados***

*   DFA debe tener un solo estado dde aceptacion que solo tiene aristas de llegada. Transciones con Epsilon.
*   El estado inicial solo debe tener transciones de salida.

Para eliminar un estado que tenga un transiciones de llegada y un transiciones de salida, ademas K transiciones hacia el mismo.
"""

from google.colab import files
from IPython.display import Image

uploades = files.upload()

Image('caminoEstados.png', width=800)

"""### **Ejemplo 1 (Eliminacion de estado)**


*Orden de elimanacion de estados*

*   Estado q2
*   Estado q1
*   Estado q0

Expresion regular = e (1+0(1+0(0)* 1)) * + 00(0)* e
"""

from google.colab import files
from IPython.display import Image

uploades = files.upload()

Image('ejemp.jpeg', width=800)

"""### **EVALUADOR DFA**

Ejemplo 1
"""

def dfa_evaluate(alphabet, states, initial_state, accepting_states, transitions, str_test):
  current_state = initial_state
  
  for char_index in range(len(str_test)):
    current_char = str_test[char_index]
    next_state = transitions[(current_state, current_char)] 
    print (current_state, current_char, next_state)
    current_state = next_state

  if current_state in accepting_states:
    print ("Pertenece a L(M)")
  else: 
    print ("No pertenece a L(M)")


#debe contener la subcadena 01
dfa = {
    'alphabet': {'0', '1'},
    'states': {'q0', 'q1', 'q2'},
    'initial_state': 'q0',
    'accepting_states': {'q2'},
    'transitions': {
        ('q0', '1'): 'q0',
        ('q0', '0'): 'q1',
        ('q1', '0'): 'q1',
        ('q1', '1'): 'q2',
        ('q2', '0'): 'q2',
        ('q2', '1'): 'q2'       
    }
}

alphabet = dfa['alphabet']
states = dfa['states']
initial_state = dfa['initial_state']
accepting_states = dfa['accepting_states']
transitions = dfa['transitions']

str_test = "10"

dfa_evaluate(alphabet, states, initial_state, accepting_states, transitions, str_test)

"""**Ejemplo 2: Validando si existe la transitions. (Falta validar el lenguaje)**"""

def dfa_evaluate(alphabet, states, initial_state, accepting_states, transitions, str_test):
  current_state = initial_state
  
  transition_exists = True

  for char_index in range(len(str_test)):
    current_char = str_test[char_index]
    
    if ((current_state, current_char) not in transitions):
      transition_exists = False
      break
    next_state = transitions[(current_state, current_char)] 
    print (current_state, current_char, next_state)
    current_state = next_state

  if transition_exists and current_state in accepting_states:
    print ("Pertenece a L(M)")
  else: 
    print ("No pertenece a L(M)")


#debe contener la subcadena 01
dfa = {
    'alphabet': {'0', '1'},
    'states': {'q0', 'q1'},
    'initial_state': 'q0',
    'accepting_states': {'q1'},
    'transitions': {
        ('q0', '1'): 'q1',
        ('q1', '0'): 'q1',
        ('q1', '1'): 'q1'
    }
}

alphabet = dfa['alphabet']
states = dfa['states']
initial_state = dfa['initial_state']
accepting_states = dfa['accepting_states']
transitions = dfa['transitions']

str_test = "1011010101"

dfa_evaluate(alphabet, states, initial_state, accepting_states, transitions, str_test)

"""### **Equivalencia de NFA a DFA**

L(M) = L(M') si M (NFA) es un DFA, M' (DFA) es una NFA y, M y M' son equivalentes.

**Pasos**

1. Desde el estado inicial q0, asignado qr = q0.
2. Para cada s que pertenece a S(alfabato), identificar los estados D(q0,s) identificadolos como qr.
3. Identificar si qr es un estado existente, repetir el paso 2.

### **Ejemplo NFA a DFA 1**

a u (ab)+
"""

from google.colab import files
from IPython.display import Image

uploades = files.upload()

Image('nfaAdfa.jpeg', width=800)